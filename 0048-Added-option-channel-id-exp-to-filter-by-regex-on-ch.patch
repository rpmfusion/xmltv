From f0becb5ecbbdbe4cbad3c6827e6878d2a58e8ac5 Mon Sep 17 00:00:00 2001
From: Honir <honir@c4b.co.uk>
Date: Fri, 15 Jan 2021 17:42:50 +0000
Subject: [PATCH 48/50] Added option --channel-id-exp to filter by regex on
 channel id (#12)

---
 filter/tv_grep.in | 41 +++++++++++++++++++++++++++++++++++++++--
 1 file changed, 39 insertions(+), 2 deletions(-)

diff --git a/filter/tv_grep.in b/filter/tv_grep.in
index 124133fc..b81f16e6 100755
--- a/filter/tv_grep.in
+++ b/filter/tv_grep.in
@@ -76,7 +76,7 @@ convenient to use the special tests described below.
 
 =head2 CHANNEL TESTS
 
-There are two tests for channels.  These filter both <programme> and
+There are three tests for channels.  These filter both <programme> and
 <channel> elements: if a channel is filtered out then all programmes
 on that channel are too.
 
@@ -84,6 +84,8 @@ B<--channel-name REGEXP> True if the channel has a <name> whose content matches
 
 B<--channel-id CHANNEL_ID> True if the channelE<39>s XMLTV id is exactly equal to CHANNEL_ID.
 
+B<--channel-id-exp REGEXP> True if the channel has a <id> whose content matches REGEXP.
+
 =head2 TIME TESTS
 
 Normally you donE<39>t want to test time strings with a regular
@@ -229,12 +231,14 @@ my (@chan_conjs, @curr_chan_conj);
 # Hash mapping regexp -> channel id -> true/undef (see later)
 my %ch_name;
 my @ch_regexps; # regexps to populate %ch_name with
+my @chid_regexps; # regexps for matching with channel id
+
 
 # Prepare an OptionAbbrev object with all the long options we expect
 # to find.
 #
 my $oa = new OptionAbbrev(qw(--ignore-case --help --output
-			     --channel-id --channel-name
+			     --channel-id --channel-name --channel-id-exp 
 			     --on-after --on-before --eval
 			     --and --or --not));
 
@@ -413,6 +417,19 @@ while (@ARGV) {
 	    next;
 	}
 
+	if (defined $lo and $lo eq '--channel-id-exp') {
+	    my $regexp = shift @ARGV;
+	    die "--channel-id-exp requires an argument, a Perl regular expression\n"
+	      if not defined $regexp;
+	    # reuses some --channel-name processing
+	    #
+	    $add_to_prog_conj->(sub { $ch_name{$regexp}->{$_->{channel}} });
+	    $add_to_chan_conj->(sub { $ch_name{$regexp}->{$_->{id}} });
+	    $not = 0;
+	    push @chid_regexps, $regexp;
+	    next;
+	}
+
 	if (defined $lo and $lo eq '--channel-name') {
 	    my $regexp = shift @ARGV;
 	    die "--channel name requires an argument, a Perl regular expression\n"
@@ -550,6 +567,25 @@ foreach my $ch_id (keys %$ch) {
     }
 }
 
+# Prepare the channel id lookup.
+my %seen_chid_id;
+foreach my $ch_id (keys %$ch) {
+    $seen_chid_id{$ch_id}++ && die "duplicate channel id $ch_id\n";
+    my $ch = $ch->{$ch_id}; die if not defined $ch;
+    my %seen_re;
+    foreach my $re (@chid_regexps) {
+		next if $seen_re{$re}++;
+		my $matched = 0;
+		if ($re eq ''
+			or ($ignore_case ? $ch_id =~ /$re/i : $ch_id =~ /$re/)) {
+			$matched = 1;
+		}
+		if ($matched) {
+			$ch_name{$re}->{$ch_id}++ && die;
+		}
+    }
+}
+
 # Filter channels.  This has an effect only for the --channel-id and
 # --channel-name predicates; we do not drop channels simply because no
 # programmes remained on them after filtering.
@@ -644,6 +680,7 @@ END
 (channel matches)
     --channel-name REGEXP
     --channel-id CHANNEL_ID
+    --channel-id-exp REGEXP
 (special tests)
     --on-after DATE
     --on-before DATE
-- 
2.29.2

